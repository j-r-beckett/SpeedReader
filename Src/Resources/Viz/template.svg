<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1 1" width="1" height="1">
  <defs>
    <style>
      .bounding-box { fill: none; stroke: red; stroke-width: 2; }
      .oriented-bounding-box { fill: none; stroke: blue; stroke-width: 2; }
      .expected-bounding-box { fill: none; stroke: black; stroke-width: 2; stroke-dasharray: 5,5; }
      .expected-oriented-bounding-box { fill: none; stroke: orange; stroke-width: 2; stroke-dasharray: 5,5; }
      .polygon { fill: none; stroke: green; stroke-width: 2; }
      .dbnet-overlay { opacity: 0.5; }
      .recognized-text {
        fill: white;
        text-shadow: 1px 1px 1px black, -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black;
        font-family: Arial, sans-serif;
        font-weight: bold;
        pointer-events: all;
      }

      .legend {
        font-family: Arial, sans-serif;
        font-size: 14px;
        background: rgba(60, 60, 60, 1);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 12px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: fit-content;
      }
      .legend-item {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        user-select: none;
      }
      .legend-item:hover { color: #ddd; }
      .legend-swatch {
        width: 20px;
        height: 6px;
        border-radius: 3px;
      }
      .hidden { display: none; }
    </style>
  </defs>

  <foreignObject x="10" y="10" width="100%" height="100%">
    <div xmlns="http://www.w3.org/1999/xhtml" class="legend">
      <div class="legend-item" data-class="bounding-boxes">
        <div class="legend-swatch" style="background-color: red"></div>
        <span>Axis-aligned bounding boxes</span>
      </div>
      <div class="legend-item" data-class="oriented-bounding-boxes">
        <div class="legend-swatch" style="background-color: blue"></div>
        <span>Oriented bounding boxes</span>
      </div>
      <div class="legend-item" data-class="expected-bounding-boxes">
        <div class="legend-swatch" style="background-color: black"></div>
        <span>Expected axis-aligned</span>
      </div>
      <div class="legend-item" data-class="expected-oriented-bounding-boxes">
        <div class="legend-swatch" style="background-color: orange"></div>
        <span>Expected oriented</span>
      </div>
      <div class="legend-item" data-class="polygons">
        <div class="legend-swatch" style="background-color: green"></div>
        <span>Polygons</span>
      </div>
      <div class="legend-item" data-class="text-overlay">
        <div class="legend-swatch" style="background-color: white"></div>
        <span>Recognized text</span>
      </div>
      <div class="legend-item" data-class="dbnet-overlay">
        <div class="legend-swatch" style="background-color: yellow"></div>
        <span>Raw detection output</span>
      </div>
    </div>
  </foreignObject>

  <script>
    <![CDATA[
    (function() {
      const data = {{VIZ_DATA}};
      const svg = document.currentScript.ownerSVGElement;

      // Update viewBox and dimensions
      svg.setAttribute('viewBox', `0 0 ${data.width} ${data.height}`);
      svg.setAttribute('width', data.width);
      svg.setAttribute('height', data.height);

      // Create base image
      const baseImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      baseImage.setAttribute('width', data.width);
      baseImage.setAttribute('height', data.height);
      baseImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.baseImageDataUri);
      svg.appendChild(baseImage);

      // Create probability map overlay if present
      if (data.probabilityMapDataUri) {
        const dbnetGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        dbnetGroup.setAttribute('class', data.defaultVisible['dbnet-overlay'] ? 'dbnet-overlay' : 'dbnet-overlay hidden');

        const probImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        probImage.setAttribute('width', data.width);
        probImage.setAttribute('height', data.height);
        probImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.probabilityMapDataUri);

        dbnetGroup.appendChild(probImage);
        svg.appendChild(dbnetGroup);
      }

      // Helper function to create polygon group
      function createPolygonGroup(polygons, className, polygonClass, defaultVisible) {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', defaultVisible ? className : className + ' hidden');

        polygons.forEach(polygon => {
          const points = polygon.points.map(p => `${p.x},${p.y}`).join(' ');
          const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          poly.setAttribute('class', polygonClass);
          poly.setAttribute('points', points);
          group.appendChild(poly);
        });

        return group;
      }

      // Create axis-aligned bounding boxes
      if (data.axisAlignedBoundingBoxes.length > 0) {
        svg.appendChild(createPolygonGroup(
          data.axisAlignedBoundingBoxes,
          'bounding-boxes',
          'bounding-box',
          data.defaultVisible['bounding-boxes']
        ));
      }

      // Create oriented bounding boxes
      if (data.orientedBoundingBoxes.length > 0) {
        svg.appendChild(createPolygonGroup(
          data.orientedBoundingBoxes,
          'oriented-bounding-boxes',
          'oriented-bounding-box',
          data.defaultVisible['oriented-bounding-boxes']
        ));
      }

      // Create expected axis-aligned bounding boxes
      if (data.expectedAxisAlignedBoundingBoxes.length > 0) {
        svg.appendChild(createPolygonGroup(
          data.expectedAxisAlignedBoundingBoxes,
          'expected-bounding-boxes',
          'expected-bounding-box',
          data.defaultVisible['expected-bounding-boxes']
        ));
      }

      // Create expected oriented bounding boxes
      if (data.expectedOrientedBoundingBoxes.length > 0) {
        svg.appendChild(createPolygonGroup(
          data.expectedOrientedBoundingBoxes,
          'expected-oriented-bounding-boxes',
          'expected-oriented-bounding-box',
          data.defaultVisible['expected-oriented-bounding-boxes']
        ));
      }

      // Create polygons
      if (data.polygons.length > 0) {
        svg.appendChild(createPolygonGroup(
          data.polygons,
          'polygons',
          'polygon',
          data.defaultVisible['polygons']
        ));
      }

      // Create text overlay
      if (data.textItems.length > 0) {
        const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        textGroup.setAttribute('class', data.defaultVisible['text-overlay'] ? 'text-overlay' : 'text-overlay hidden');

        data.textItems.forEach(item => {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', item.centerX);
          text.setAttribute('y', item.centerY);
          text.setAttribute('font-size', item.fontSize + 'px');
          text.setAttribute('transform', `rotate(${item.rotationAngle}, ${item.centerX}, ${item.centerY})`);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'central');
          text.setAttribute('class', 'recognized-text');

          const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
          title.textContent = (item.confidence * 100).toFixed(1) + '%';
          text.appendChild(title);

          text.appendChild(document.createTextNode(item.text));
          textGroup.appendChild(text);
        });

        svg.appendChild(textGroup);
      }

      // Move legend to end so it renders on top of other elements
      const legend = svg.querySelector('foreignObject');
      svg.appendChild(legend);

      // Hardcoded mapping: legend item class -> check if data exists
      const legendDataMap = {
        'bounding-boxes': data.axisAlignedBoundingBoxes.length > 0,
        'oriented-bounding-boxes': data.orientedBoundingBoxes.length > 0,
        'expected-bounding-boxes': data.expectedAxisAlignedBoundingBoxes.length > 0,
        'expected-oriented-bounding-boxes': data.expectedOrientedBoundingBoxes.length > 0,
        'polygons': data.polygons.length > 0,
        'text-overlay': data.textItems.length > 0,
        'dbnet-overlay': !!data.probabilityMapDataUri
      };

      // Initialize legend items: hide if no data, set initial visibility state
      svg.querySelectorAll('.legend-item').forEach(item => {
        const cls = item.dataset.class;
        const hasData = legendDataMap[cls];

        if (!hasData) {
          item.style.display = 'none';
        } else {
          const visible = data.defaultVisible[cls] ?? false;
          item.style.opacity = visible ? '1' : '0.5';
          item.onclick = () => toggleLayer(cls);
        }
      });

      // Toggle layer function
      function toggleLayer(className) {
        const elements = svg.querySelectorAll('.' + className);
        const legendItem = svg.querySelector('.legend-item[data-class="' + className + '"]');

        elements.forEach(element => {
          if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
            legendItem.style.opacity = '1';
          } else {
            element.classList.add('hidden');
            legendItem.style.opacity = '0.5';
          }
        });
      }
    })();
    ]]>
  </script>
</svg>
