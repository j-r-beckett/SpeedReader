# /// script
# requires-python = ">=3.11"
# dependencies = ["marimo"]
# ///
#
# WARNING: Do not edit this file in marimo. Edit as raw Python only.
# Marimo corrupts @app.function on save.

import marimo

__generated_with = "0.18.4"
app = marimo.App()

with app.setup:
    import marimo as mo
    import subprocess
    from pathlib import Path


@app.function
def build_inference_benchmark() -> None:
    """Build the MicroBenchmarks project."""
    project_path = Path(__file__).parent.parent / "src" / "MicroBenchmarks"

    with mo.status.spinner(title="Building MicroBenchmarks..."):
        build_result = subprocess.run(
            ["dotnet", "build", str(project_path), "--verbosity", "quiet"],
            capture_output=True,
            text=True,
        )
    if build_result.returncode != 0:
        raise RuntimeError(f"Build failed:\n{build_result.stderr}")

    return True


@app.function
def run_inference_benchmark(
    model: str,
    batch_size: int = 1,
    intra_threads: int = 1,
    inter_threads: int = 1,
    parallelism: int = 1,
    iterations: int = 100,
    warmup: int = 10,
) -> list[float]:
    """
    Run inference benchmark and return timing data (milliseconds).

    Assumes project is already built (call build_inference_benchmark first).
    Shows progress bar during execution.
    """
    project_path = Path(__file__).parent.parent / "src" / "MicroBenchmarks"

    proc = subprocess.Popen(
        [
            "dotnet", "run",
            "--project", str(project_path),
            "--no-build",
            "--", "inference",
            "-m", model,
            "-b", str(batch_size),
            "--intra-threads", str(intra_threads),
            "--inter-threads", str(inter_threads),
            "-p", str(parallelism),
            "-n", str(iterations),
            "-w", str(warmup),
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )

    results = []
    with mo.status.progress_bar(total=iterations, title="Running benchmark") as bar:
        for line in proc.stdout:
            results.append(float(line.strip()))
            bar.update()

    proc.wait()
    if proc.returncode != 0:
        raise RuntimeError(f"Benchmark failed:\n{proc.stderr.read()}")

    return results


if __name__ == "__main__":
    app.run()
